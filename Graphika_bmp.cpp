#include "bibl_c.cpp"
#include <io.h>
#include <fcntl.h>
#include <memory.h>
#include <sys/stat.h>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Объединение используемое для преобразования типа "unsigned long" в "unsigned char" и обратно.
//

union
{
	unsigned long ul;
	unsigned char uch[4];

} perevod4;
	

//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////// 	Функция создания файла изображения в формате BMP		//////////////
//
//
//	Входные параметры :	
//				
//		Xmax	- Размер изображения в пикселях по горизонтали
//		Ymax	- Размер изображения в пикселях по вертикали
//		cs	- Цвет фона синяя составляющая
//		cz	- Цвет фона зеленая составляющая	
//		ck	- Цвет фона красная составляющая
//
//
//	Выходные параметры :
//
//		** buf1	- Указатель на область памяти в которой размещено изображение
//
//	Возвращаемое значение :
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения
//


int create_bmp( unsigned long Xmax, unsigned long Ymax, unsigned char cs, unsigned char cz, unsigned char ck, unsigned char * * buf1 )
{

unsigned char * buf;	// Указатель на область памяти в которой записан образ BMP-файла
unsigned long i;		// Счетчик цикла
unsigned long kol_dobaw;	// Количество добавочных байт в строке изображения.
unsigned long razmer_izobr;	// Размер графического изображения в байтах
unsigned long dlina_file;	// Размер выделяемой области памяти для хранения изображения
unsigned long sdw_obl_dan;	// Смещение области данных относительно начала файла
unsigned long dlina_inf_zagol;	// Длина информационного заголовка BMP файла
unsigned long X,Y;		// Координата текущей точки
unsigned long poz;		// Указатель на позицию в буфере BMP-файла


// Определить количество добавочных байт в строке изображения.
kol_dobaw = (unsigned long) fmod( (double) Xmax, 4.00);


// Задать смещение области данных относительно начала файла
sdw_obl_dan = 54;


// Задать длину информационного заголовка BMP файла
dlina_inf_zagol = 40;


// Определить размер графического изображения в байтах.
razmer_izobr = (Xmax*3+kol_dobaw)*Ymax;


// Установить размер файла изображения.
dlina_file = razmer_izobr + sdw_obl_dan;


// Выделение области памяти для хранения образа файла изображения в формате BMP.
buf = (unsigned char *) malloc(dlina_file);


// Если произошла неудача при выделении области памяти для хранения образа файла изображения тогда 
// выход из функции с возвратом кода ошибки.
if (buf==NULL) return 0;


// Заполнить выделенную область памяти "0".
memset(buf, 0, dlina_file);


// Записать в первые два байта образа файла изображения "BM".
buf[0] = 'B';
buf[1] = 'M';


// Начиная с позиции № 2 записать 4 байта устанавливающие размер файла изображения в байтах.
perevod4.ul = dlina_file;
for (i=0; i<4; i++) buf[i+2]=perevod4.uch[i];


// Начиная с позиции № 10 записать 4 байта устанавливающие смещение области данных относительно начала файла = 54
perevod4.ul = sdw_obl_dan;
for (i=0; i<4; i++) buf[i+10]=perevod4.uch[i];


// Начиная с позиции № 14 записать 4 байта устанавливающие длину информационного заголовка = 40
perevod4.ul = dlina_inf_zagol;
for (i=0; i<4; i++) buf[i+14]=perevod4.uch[i];


// Начиная с позиции № 18 записать 4 байта устанавливающие длину изображения по горизонтали в пикселях.
perevod4.ul = Xmax;
for (i=0; i<4; i++) buf[i+18]=perevod4.uch[i];


// Начиная с позиции № 22 записать 4 байта устанавливающие длину изображения по вертикаликали в пикселях.
perevod4.ul = Ymax;
for (i=0; i<4; i++) buf[i+22]=perevod4.uch[i];


// Начиная с позиции № 26 записать 2 байта устанавливающие количество цветовых плоскостей = 1
perevod4.ul = 1;
for (i=0; i<2; i++) buf[i+26]=perevod4.uch[i];


// Начиная с позиции № 28 записать 2 байта устанавливающие количество бит на пиксель = 24
perevod4.ul = 24;
for (i=0; i<2; i++) buf[i+28]=perevod4.uch[i];


// Начиная с позиции № 30 записать 4 байта устанавливающие тип сжатия данных = 0 (без сжатия).
perevod4.ul = 0;
for (i=0; i<4; i++) buf[i+30]=perevod4.uch[i];


// Начиная с позиции № 34 записать 4 байта устанавливающие размер графического изображения в байтах.
perevod4.ul = razmer_izobr;
for (i=0; i<4; i++) buf[i+34]=perevod4.uch[i];


// Начиная с позиции № 38 записать 4 байта устанавливающие разрешение по горизонтали = 0
perevod4.ul = 0;
for (i=0; i<4; i++) buf[i+38]=perevod4.uch[i];


// Начиная с позиции № 42 записать 4 байта устанавливающие разрешение по вертикали.
perevod4.ul = 0;
for (i=0; i<4; i++) buf[i+42]=perevod4.uch[i];


// Заполнить поле изображения цветом (cs,  cz, ck)
for(Y=0; Y<Ymax; Y++)
{	
	for ( X=0; X< Xmax; X++)
	{
		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz=sdw_obl_dan+(Xmax*3+kol_dobaw)*Y+X*3;

		// Записать в буфер цвет новой точки.
		buf[poz]     = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}
}




// Выходной переменной присвоить адрес буфера в котором записан файл изображения
* buf1=buf;


// Выход из функции с возвратом кода успешного завершения.
return 1;

}


//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////// 	Функция открытия файла изображения в формате BMP		//////////////
//
//
//	Входные параметры :	
//
//		file_name - Имя файла в котором храниться изображение в формате BMP
//
//
//	Выходные параметры :	
//
//	     	 ** buf1 - Указатель на область памяти в которой размещено изображение
//
//
//	Возвращаемое значение :		
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения		
//		


int open_bmp( char * file_name, unsigned char * * buf1 )

{

int f;			// Файловый дескриптор 
unsigned long dlina_file;	// Длина файла в байтах	
unsigned char * buf;	// Указатель на область памяти в которой записан образ BMP-файла


// Открыть указанный файл изображения
f=open(file_name, O_WRONLY | O_BINARY, 0);

// Если файл открыть не удалось тогда выход из функции с возвратом кода ошибки.
if (f == -1) return 0;


// Определить размер файла изображения
lseek(f,0L,2);
dlina_file = tell(f);


// Выделить область памяти (буфер) для хранения файла изображения
buf = (unsigned char *) malloc(dlina_file); 

if (buf == NULL) 
{
	// Ошибка при выделении памяти для хранения файла изображения

	// Закрыть ранее открытый файл
	close(f);	

	// Выход из функции с возвратом кода ошибки.
	return 0;
}


// Считать файл изображения в буфер
lseek(f,0L,0);
read(f,buf,dlina_file);


// Закрыть ранее открытый файл
close(f);	


// Выходной переменной присвоить адрес буфера в котором записан файл изображения
* buf1=buf;

// Выход из функции с возвратом признака удачного завершения.
return 1;


}


//////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////// 	Функция сохранения файла изображения в формате BMP		//////////////
//
//
//	Входные параметры :	
//
//		file_name - Имя файла в котором сохраниться изображение в формате BMP
//		buf 	  - Указатель на область памяти в которой размещено изображение	
//
//	Возвращаемое значение :		
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения		
//		


int save_bmp( char * file_name, unsigned char * buf )

{

int f;				// Файловый дескриптор 
unsigned long dlina_file;	// Длина файла в байтах	
unsigned long i;		// Счетчик цикла


// Создать файл для записи изображения.
f=open(file_name, O_CREAT | O_WRONLY | O_BINARY, S_IWRITE );




// Если файл создать не удалось тогда выход из функции с возвратом кода ошибки.
if (f == -1) return 0;


// Считать длину файла
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+2];
dlina_file = perevod4.ul;


// Содержимое буфера записать в файл.
write(f, buf, dlina_file);


// Закрыть файл
close(f);


// Освободить буфер
free(buf);


// Выход из функции с возвратом признака удачного завершения.
return 1;


}


//////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////// 		Функция рисования точки					//////////////
//
//
//	Входные параметры :
//
//		buf 	- Указатель на область памяти в которой размещено изображение
//		X	- Координата x точки
//		Y	- Координата y точки
//		cs	- Цвет точки синяя составляющая
//		cz	- Цвет точки зеленая составляющая
//		ck	- Цвет точки красная составляющая
//
//
//	Возвращаемое значение :
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения
//


int point( unsigned char * buf, long X, long Y, unsigned char cs, unsigned char cz, unsigned char ck )
{


unsigned long i;		// Счетчик цикла
unsigned long sdw_obl_dan;	// Сдвиг области данных относительно начала файла
unsigned long poz;		// Позиция в файле начиная с которой надо записывать цвет точки
unsigned long kol_dobaw;	// Количество добавочных байт в строке изображения
int code_ret;		// Код возвращаемый при завершении функции

long Xmax;		// Размер изображения по горизонтали
long Ymax;		// Размер изображения по вертикали


// Считать сдвиг области данных относительно начала буфера.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+10];
sdw_obl_dan=perevod4.ul;


// Считать размер изображения по горизонтали
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+18];
Xmax = (long) perevod4.ul;


// Считать размер изображения по вертикали.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+22];
Ymax= (long) perevod4.ul;


// Определить количество добавочных байт в строке изображения
kol_dobaw = (unsigned long) fmod( (double) Xmax, 4.00);	


// Преобразование координаты Y
Y = Ymax-Y;


if ( (0<=X) && (X<Xmax) && (0<=Ymax) && (Y<Ymax))
{
	// Точка с координатами (X,Y) попадает в поле изображения

	// Определить позицию в буфере куда надо записать цвет новой точки.
	poz=sdw_obl_dan+((long)Xmax*3+kol_dobaw)*Y+X*3;

	// Записать в буфер цвет новой точки.
	buf[poz]   = cs;	
	buf[poz+1] = cz;
	buf[poz+2] = ck;

	// Установить код удачного завершения.
	code_ret = 1;
}
else
{
	// Точка с координатами (X,Y) не попадает в поле изображения
	// Установить код неудачного завершения.
	code_ret = 0;
}


// Выход из функции с возвратом кода завершения.
return code_ret;


}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////// 		Функция рисования прямой				/////////////
//
//
//	Входные параметры :
//
//		buf 	- Указатель на область памяти в которой размещено изображение
//		X1	- Координата x начальной точки прямой
//		Y1	- Координата y начальной точки прямой
//		X2	- Координата x конечной точки прямой
//		Y2	- Координата y конечной точки прямой
//		cs	- Цвет прямой синяя составляющая
//		cz	- Цвет прямой зеленая составляющая
//		ck	- Цвет прямой красная составляющая
//
//
//	Возвращаемое значение :
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения
//


int line( unsigned char * buf, long X1, long Y1, long X2, long Y2, unsigned char cs, unsigned char cz, unsigned char ck )
{

unsigned long i;		// Счетчик цикла
unsigned long sdw_obl_dan;	// Сдвиг области данных относительно начала файла
unsigned long kol_dobaw;	// Количество добавочных байт в строке изображения
unsigned long poz;		// Позиция в файле начиная с которой записывается текущая точка изображения
double k;			// Коэффициент наклона прямой

long X,Y;		// Координаты точек расположенных на прямой
long Xp,Yp;	// Вспомогательные переменные
long Xmax;	// Размер изображения по горизонтали
long Ymax;	// Размер изображения по вертикали


// Считать сдвиг области данных относительно начала буфера.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+10];
sdw_obl_dan=perevod4.ul;


// Считать размер изображения по горизонтали
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+18];
Xmax= (long) perevod4.ul;


// Считать размер изображения по вертикали.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+22];
Ymax=(long) perevod4.ul;


// Определить количество добавочных байт в строке изображения
kol_dobaw = (unsigned long) fmod( (double) Xmax, 4.00);


// Преобразование Y1 и Y2
Y1 = Ymax - Y1;
Y2 = Ymax - Y2;


if (X2!=X1)
{
	//  Координаты X начальной и конечной точки не совпадают

	if ( fabs(((double)X2)-((double)X1)) >= fabs(((double)Y2)-((double)Y1)) )
	{
		//  | X2-X1 | >= | Y2-Y1 |

		if ( X2<X1)
		{
			// Поменять местами начальную и конечную точку линии
			Xp = X2;
			Yp = Y2;
			X2 = X1;
			Y2 = Y1;
			X1 = Xp;
			Y1 = Yp;
		}

		// Определить коэффициент наклона прямой
		k = (((double)Y2)-((double)Y1))/(((double)X2)-((double)X1));

		// Перебор в цикле всех точек линии по оси Х и ее рисование
		for (X=X1; X<=X2; X++)
		{
			// Определить координату Y очередной точки прямой
			Y = (long)(k * ((double)X-(double)X1))+((double)Y1);

			if ( (0<=X) && (X<Xmax) && (0<=Y) && (Y<Ymax))
			{
				// Точка с координатами (X,Y) попадает в поле изображения

				// Определить позицию в буфере куда надо записать цвет новой точки.
				poz=sdw_obl_dan+( (unsigned long)Xmax*3+kol_dobaw)*Y+X*3;

				// Записать в буфер цвет новой точки.
				buf[poz]   = cs;
				buf[poz+1] = cz;
				buf[poz+2] = ck;
			}
		}
	}
	else
	{
		//  | X2-X1 | < | Y2-Y1 |

		if ( Y2<Y1)
		{
			// Поменять местами начальную и конечную точку линии
			Xp = X2;
			Yp = Y2;
			X2 = X1;
			Y2 = Y1;
			X1 = Xp;
			Y1 = Yp;
		}

		// Определить коэффициент наклона прямой
		k = (((double)X2)-((double)X1))/(((double)Y2)-((double)Y1));

		// Перебор в цикле всех точек линии по оси Х и ее рисование
		for (Y=Y1; Y<=Y2; Y++)
		{
			// Определить координату X очередной точки прямой
			X = (long)(k * ((double)Y-(double)Y1))+((double)X1);

			if (  (0<=X) && (X<Xmax) && (0<=Y) && (Y<Ymax))
			{
				// Точка с координатами (X,Y) попадает в поле изображения

				// Определить позицию в буфере куда надо записать цвет новой точки.
				poz=sdw_obl_dan+((unsigned long)Xmax*3+kol_dobaw)*Y+X*3;

				// Записать в буфер цвет новой точки.
				buf[poz]   = cs;
				buf[poz+1] = cz;
				buf[poz+2] = ck;
			}
		}
	}
}
else
{
	// Координаты X начальной и конечной точки совпадают

	if ( Y2<Y1)
	{
		// Поменять местами начальную и конечную точку линии
		Yp = Y2;
		Y2 = Y1;
		Y1 = Yp;
	}

	// Задать координату X вертикальной прямой линии
	X=X1;

	// Перебор в цикле всех точек линии и ее рисование
	for (Y=Y1; Y<=Y2; Y++)
	{
		if (  (0<=X) && (X<Xmax) && (0<=Y) && (Y<Ymax))
		{
			// Точка с координатами (X,Y) попадает в поле изображения

			// Определить позицию в буфере куда надо записать цвет новой точки.
			poz=sdw_obl_dan+((unsigned long)Xmax*3+kol_dobaw)*Y+X*3;

			// Записать в буфер цвет новой точки.
			buf[poz]   = cs;
			buf[poz+1] = cz;
			buf[poz+2] = ck;
		}
	}
}



// Выход из функции с возвратом кода удачного завершения
return 1;

}


/////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////// 		Функция рисования окружности				/////////////
//
//
//	Входные параметры :
//
//		buf 	- Указатель на область памяти в которой размещено изображение
//		Xc	- Координата X центра окружности
//		Yc	- Координата Y центра окружности
//		R	- Радиус окружности
//		cs	- Цвет окружности синяя составляющая
//		cz	- Цвет окружности зеленая составляющая
//		ck	- Цвет окружности красная составляющая
//
//
//	Возвращаемое значение :
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения
//


int krug( unsigned char * buf,  long Xc, long Yc,  long R, unsigned char cs, unsigned char cz, unsigned char ck )
{


unsigned long i;		// Счетчик цикла
unsigned long sdw_obl_dan;	// Сдвиг области данных относительно начала файла
unsigned long kol_dobaw;	// Количество добавочных байт в строке изображения
unsigned long poz;		// Текущая позиция в буфере

long X,Y;		// Координаты X,Y точки окружности
long X1_okr;	// Координата Х левой точки фрагмента окружности ( при рисовании вдоль оси  X )
long X2_okr;	// Координата Х правой точки фрагмента окружности ( при рисовании вдоль оси  X )
long Y1_okr;	// Координата Y нижней точки фрагмента окружности ( при рисовании вдоль оси  Y )
long Y2_okr;	// Координата Y верхней точки фрагмента окружности ( при рисовании вдоль оси  Y )
long Xmax;	// Размер изображения по горизонтали
long Ymax;	// Размер изображения по вертикали



// Считать сдвиг области данных относительно начала буфера.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+10];
sdw_obl_dan=perevod4.ul;

// Считать размер изображения по горизонтали
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+18];
Xmax= (long) perevod4.ul;

// Считать размер изображения по вертикали.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+22];
Ymax= (long) perevod4.ul;

// Определить количество добавочных байт в строке изображения
kol_dobaw = (unsigned long) fmod( (double) Xmax, 4.00);

// Преобразование Yc
Yc = Ymax - Yc;



// Определить координату X левой точки фрагмента окружности
X1_okr = Xc - (long) ((double) R * 0.7071067811)  ;

// Определить координату  X правой точки фрагмента окружности
X2_okr = Xc + (long) ((double) R * 0.7071067811)  ;

// Рисование фрагмента окружности вдоль оси X
for (X=X1_okr; X<=X2_okr; X++)
{
	// Определить координату Y верхнего полукруга
	Y = (long) ((double)Yc+sqrt(sqr((double)R)-sqr((double)X-(double)Xc)));

	if (  (0<=X) &&  (X<Xmax) && (0<=Y) && (Y<Ymax) )
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)Y)+((unsigned long)X)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}

	// Определить координату Y нижнего полукруга
	Y = (long) ((double)Yc-sqrt(sqr((double)R)-sqr((double)X-(double)Xc)));

	if ( (0<=X) && (X<Xmax) && (0<=Y) && (Y<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)Y)+((unsigned long)X)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}
}


// Определить координату Y нижней точки окружности
Y1_okr = Yc - (long) ((double) R * 0.7071067811)  ;

// Определить координату  Y верхней точки окружности
Y2_okr = Yc + (long) ((double) R * 0.7071067811)  ;

// Рисование фрагмента окружности вдоль оси Y
for (Y=Y1_okr; Y<=Y2_okr; Y++)
{
	// Определить координату X правого полукруга
	X = (long) ((double)Xc+sqrt(sqr((double)R)-sqr((double)Y-(double)Yc)));

	if ( (0<=X) && (X<Xmax) && (0<=Y) && (Y<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)Y)+((unsigned long)X)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}

	// Определить координату X левого полукруга
	X = (long) ((double)Xc-sqrt(sqr((double)R)-sqr((double)Y-(double)Yc)));

	if ( (0<=X) && (X<Xmax) && (0<=Y) && (Y<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)Y)+((unsigned long)X)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}
}



// Выход из функции с возвратом кода успешного завершения
return 1;


}


/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////// 			Функция рисования эллипса				/////////////
//
//
//	Входные параметры :
//
//		buf 	- Указатель на область памяти в которой размещено изображение
//		Xc	- Координата x центра эллипса
//		Yc	- Координата y центра эллипса
//		a	- Длина большей полуоси эллипса
//		b	- Длина большей полуоси эллипса
//	alfa_gradus	- Угол поворота эллипса в градусах
//		cs	- Цвет эллипса синяя составляющая
//		cz	- Цвет эллипса зеленая составляющая
//		ck	- Цвет эллипса красная составляющая
//
//
//	Возвращаемое значение :
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения
//

int ellips( unsigned char * buf,  long Xc,  long Yc,  long a,  long b,  double alfa_gradus,  unsigned char cs, unsigned char cz, unsigned char ck )

{

double pi=3.14159;		// Число пи

unsigned long i;		// Счетчик цикла
unsigned long sdw_obl_dan;	// Сдвиг области данных относительно начала файла
unsigned long kol_dobaw;	// Количество добавочных байт в строке изображения
unsigned long poz;		// Текущая позиция в буфере

long X_lev;		// Координата Х левой границы участка рисуемой вдоль оси Х
long X_prav;		// Координата Х правой границы участка рисуемой вдоль оси Х

long Y_nig;		// Координата Y нижней границы участка рисуемого вдоль оси Y
long Y_werh;		// Координата Y верхней границы участка рисуемого вдоль оси Y

long X,Y;			// Координаты X,Y точки эллипса
long Xmax;		// Размер изображения по горизонтали
long Ymax;		// Размер изображения по вертикали
long XX, YY;		// Координаты X,Y точки эллипса, после поворота

double alfa_radian;		// Угол поворота эллипса в радианах
double a2_plus_b2;	// Вспомогательная переменная
double Diskrim;		// Вспомогательная переменная
double Xp1;		// Координата "Х" точки перегиба верхней части эллипса. Вариант № 1



if (a == b)
{
	// Полуоси эллипса равны.

	// Выход из функции с возвратом кода ошибочного завершения
	return 0;
}

// Считать сдвиг области данных относительно начала буфера.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+10];
sdw_obl_dan=perevod4.ul;

// Считать размер изображения по горизонтали
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+18];
Xmax = (long) perevod4.ul;

// Считать размер изображения по вертикали.
for (i=0; i<4; i++) perevod4.uch[i]=buf[i+22];
Ymax = (long) perevod4.ul;

// Определить количество добавочных байт в строке изображения
kol_dobaw = (unsigned long) fmod( (double) Xmax, 4.00);

// Преобразование Yc
Yc = Ymax - Yc;

// Перевод угла поворота эллипса из градусов в радианы
alfa_radian =  alfa_gradus * pi/180;

// Определить координату "X" точки перегиба верхней части эллипса (где производная равна 1).
a2_plus_b2 = sqr( (double) a) + sqr( (double) b);
Diskrim = sqr(2*(double)Xc*a2_plus_b2) - 4*a2_plus_b2*(a2_plus_b2*sqr((double)Xc) - (double) a*a*a*a);

if (Diskrim < 0)
{
	// Если дискриминант отрицательный тогда выход из функции с возвратом кода ошибки.
	return 0;
}

Xp1 =  (2*(double)Xc*a2_plus_b2-sqrt(Diskrim)) / (2*a2_plus_b2);

// Определить левую границу участка рисуемого вдоль оси Х
X_lev = Xp1;

// Определить правую границу участка рисуемого вдоль оси Х
X_prav = Xc + labs(Xc-Xp1)+1;


// Рисование участка эллипса вдоль оси Х

for(X=X_lev; X<=X_prav;  X++)
{
	// Определить координату Y верхней части эллипса
	Y = (long) Yc + b * sqrt(1-sqr(X-Xc)/sqr(a));

	// Поворот эллипса вокруг своего центра на угол "alfa_radian"
	XX = (long) (X-Xc)*cos(alfa_radian)  -  (Y-Yc)*sin(alfa_radian) + Xc;
	YY = (long) (X-Xc)*sin(alfa_radian)  + (Y-Yc)*cos(alfa_radian) + Yc;

	if ((0<=XX) &&  (XX<Xmax) &&  (0<=YY) && (YY<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)YY)+((unsigned long)XX)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}

	// Определить координату Y нижней части эллипса
	Y = (long) Yc - b * sqrt(1-sqr(X-Xc)/sqr(a));

	// Поворот эллипса вокруг своего центра на угол "alfa_radian"
	XX = (long) (X-Xc)*cos(alfa_radian)  - (Y-Yc)*sin(alfa_radian) + Xc;
	YY = (long) (X-Xc)*sin(alfa_radian)  + (Y-Yc)*cos(alfa_radian) + Yc;

	if ((0<=XX) &&  (XX<Xmax) &&  (0<=YY) && (YY<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)YY)+((unsigned long)XX)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}
}


// Определить нижнюю границу участка рисуемого вдоль оси Y
Y_nig =	 (long) Yc - b * sqrt(1-sqr(X_lev-Xc)/sqr(a));

// Определить верхнюю границу участка рисуемого вдоль оси Y
Y_werh =  (long) Yc + b * sqrt(1-sqr(X_lev-Xc)/sqr(a));


// Рисование участка эллипса вдоль оси Y

for(Y=Y_nig; Y<=Y_werh; Y++)
{
	// Определить координату X левой части эллипса
	X = (long) Xc - a * sqrt(1-sqr(Y-Yc)/sqr(b));

	// Поворот эллипса вокруг своего центра на угол "alfa_radian"
	XX = (long) (X-Xc)*cos(alfa_radian)  -  (Y-Yc)*sin(alfa_radian) + Xc;
	YY = (long) (X-Xc)*sin(alfa_radian)  + (Y-Yc)*cos(alfa_radian) + Yc;

	if ((0<=XX) &&  (XX<Xmax) &&  (0<=YY) && (YY<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)YY)+((unsigned long)XX)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}

	// Определить координату X правой части эллипса
	X = (long) Xc + a * sqrt(1-sqr(Y-Yc)/sqr(b));

	// Поворот эллипса вокруг своего центра на угол "alfa_radian"
	XX = (long) (X-Xc)*cos(alfa_radian)  - (Y-Yc)*sin(alfa_radian) + Xc;
	YY = (long) (X-Xc)*sin(alfa_radian)  + (Y-Yc)*cos(alfa_radian) + Yc;

	if ((0<=XX) &&  (XX<Xmax) &&  (0<=YY) && (YY<Ymax))
	{
		// Точка с координатами (X,Y) попадает в поле изображения

		// Определить позицию в буфере куда надо записать цвет новой точки.
		poz = sdw_obl_dan + ((unsigned long)Xmax*3+kol_dobaw)*((unsigned long)YY)+((unsigned long)XX)*3;

		// Записать в буфер цвет новой точки
		buf[poz]   = cs;
		buf[poz+1] = cz;
		buf[poz+2] = ck;
	}

}


// Выход из функции с возвратом кода успешного завершения
return 1;

}

/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////// 		Функция рисования кривой проходящей через три точки		/////////////

//
//
//	Входные параметры :
//				
//		buf 	- Указатель на область памяти в которой размещено изображение		
//		X1	- Координата x точки № 1
//		Y1	- Координата y точки № 1
//		X2	- Координата x точки № 2
//		Y2	- Координата y точки № 2
//		X3	- Координата x точки № 3
//		Y3	- Координата y точки № 3
//		cs	- Цвет кривой синяя составляющая
//		cz	- Цвет кривой зеленая составляющая	
//		ck	- Цвет кривой красная составляющая
//
//
//	Возвращаемое значение :		
//
//		1 - Признак удачного выполнения, 0 - Признак неудачного выполнения
//


int duga( unsigned char * buf, long X1, long Y1, long X2, long Y2, long X3, long Y3, unsigned char cs, unsigned char cz, unsigned char ck )
{

double * matr_X;		// Указатель на матрицу коэффициентов системы линейных уравнений
double * stolb_Y;		// Указатель на столбец свободных членов системы линейных уравнений
double * xx;		// Указатель на столбец в который записывается решение системы линейных уравнений
double opr;		// Определитель матрицы коэффициентов системы линейных уравнений
double a, b, c;		// Коэффициенты квадратичного полинома
long X,Y;			// Координаты точек расположенных на дуге
int nom_oborot;		// Номер оборота цикла рисования дуги
int code_ret;		// Код возвращаемый при завершении функции
long Xpred, Ypred;		//  X и Y на предыдущем обороте цикла
int priz;			// Признак удачи рисования линии


// Выделить область памяти для хранения матрицы 3 Х 3 коэффициентов системы линейных уравнений
matr_X = (double *) malloc(3*3*sizeof(double)); 

if (matr_X == NULL)
{
	// Ошибка при выделении области памяти для хранения матрицы 3 Х 3 
	// Выход из функции с возвратом кода неудачного завершения
	return 0;
}

// Заполнение матрицы 3 Х 3 коэффициентов системы линейных уравнений
*(matr_X + 0*3 + 0) = (double) X1*X1;	*(matr_X + 0*3 + 1) = (double) X1;	*(matr_X + 0*3 + 2) = 1.0;
*(matr_X + 1*3 + 0) = (double) X2*X2;	*(matr_X + 1*3 + 1) = (double) X2;	*(matr_X + 1*3 + 2) = 1.0;
*(matr_X + 2*3 + 0) = (double) X3*X3;	*(matr_X + 2*3 + 1) = (double) X3;	*(matr_X + 2*3 + 2) = 1.0;


// Выделить область памяти для хранения столбца свободных членов системы линейных уравнений
stolb_Y = (double *) malloc(3*sizeof(double));

if (stolb_Y == NULL)
{
	// Ошибка привыделении памяти для хранения столбца 1 Х 3

	// Освободить ранее выделенные блоки памяти.
	free(matr_X);

	// Выход из функции с возвратом кода неудачного завершения
	return 0;
}


// Заполнение столбца свободных членов системы линейных уравнений
*(stolb_Y + 0) = (double) Y1;
*(stolb_Y + 1) = (double) Y2;
*(stolb_Y + 2) = (double) Y3;


// Решение системы линейных уравнений методом Гаусса и получение коэффициентов квадратичного полинома
opr=gaus( matr_X, stolb_Y, &xx, 3 );

if (opr!=0.0)
{
	// Определитель не равен 0. Решение системы линейных уравнений найдено.

	// Считать найденные коэффициенты полинома.
	a = xx[0];
	b = xx[1];
	c = xx[2];

	// Освободить область памяти хранящей столбец решений системы линейных уравнений являющихся коэффициентами квадратичного полинома
	free(xx);

	// Задать начальное значение предыдущих X и Y
	Xpred = 0;
	Ypred = 0;

	// Перебор в цикле всех точек дуги и ее рисование

	for (X=X1,nom_oborot=1; X<=X3; X++,nom_oborot++)
	{
		// Определить координату Y очередной точки кривой
		Y = (long) (a * ((double)X) * ((double)X) + (b * (double)X) + c);

		if (nom_oborot > 1)
		{ 	
			priz = line( buf,   Xpred,Ypred,   X,Y,  cs, cz, ck );
			if (priz !=1) break;
		}
		
		// Запомнить текущее значение координат X и Y
		Xpred = X;
		Ypred = Y;
	}

	if (priz)
	{	
		// Установить код удачного завершения
		code_ret = 1;
	}
	else
	{
		// Установить код неудачного выполнения.
		code_ret = 0;
	}
	
}
else
{
	// Определитель равен 0. Решение системы линейных уравнений не найдено.

	// Установить код неудачного завершения
	code_ret = 0;
}




// Освободить область памяти выделенную для хранения матрицы 3 х 3 коэффициентов системы линейных уравнений
free(matr_X);

// Освободить область памяти выделенную для хранения столбца свободных членов сисетмы линейных уравнений
free(stolb_Y);




// Выход из функции с возвратом кода завершения
return code_ret;


}

///////////////////////////////////////////////////////////////////////////////////
///////////////////			ВЫЗОВ ГЛАВНОЙ ФУНКЦИИ			///////////////////////

/*

int main()
{

unsigned long Xmax;	// Размер изображения в пикселях по горизонтали
unsigned long Ymax;	// Размер изображения в пикселях по вертикали

unsigned char cs;	// Цвет фона синяя составляющая
unsigned char cz;	// Цвет фона зеленая составляющая
unsigned char ck;	// Цвет фона красная составляющая

int priz;		// Признак удачного выполнения
unsigned char * buf;	// Указатель на буфер



// Размер изображения в пикселях по горизонтали
Xmax= 106;

// Размер изображения в пикселях по вертикали
Ymax= 100;



// Цвет фона синяя составляющая
cs = 255;

// Цвет фона зеленая составляющая
cz = 255;

// Цвет фона красная составляющая
ck = 255;



// Тестирование функции "create_bmp()"  -  Функция создания BMP - файла
priz = create_bmp( Xmax, Ymax, cs, cz, ck, &buf );

// Выдать возвращаемое значение
printf("\n priz =  %d   ",priz );


// Нарисовать точку .
priz = point( buf, 30, 1, 0, 0, 0 );

// Выдать возвращаемое значение
printf("\n priz =  %d   ",priz );


// Нарисовать линию
priz = line( buf, 50, 50, 50, 10,    0,   0,   0 );
priz = line( buf, 50, 50, 60, 20,   10,  10,  10 );
priz = line( buf, 50, 50, 70, 30,   20,  20,  20 );
priz = line( buf, 50, 50, 80, 40,   30,  30,  30 );
priz = line( buf, 50, 50, 90, 50,   40,  40,  40 );

priz = line( buf, 50, 50, 80, 60,   60,  60,  60 );
priz = line( buf, 50, 50, 70, 70,   70,  70,  70 );
priz = line( buf, 50, 50, 60, 80,   80,  80,  80 );
priz = line( buf, 50, 50, 50, 90,   90,  90,  90 );

priz = line( buf, 50, 50, 40, 80,  100, 100, 100 );
priz = line( buf, 50, 50, 30, 70,  110, 110, 110 );
priz = line( buf, 50, 50, 20, 60,  120, 120, 120 );
priz = line( buf, 50, 50, 10, 50,  130, 130, 130 );

priz = line( buf, 50, 50, 20, 40,  140, 140, 140 );
priz = line( buf, 50, 50, 30, 30,  150, 150, 150 );
priz = line( buf, 50, 50, 40, 20,  160, 160, 160 );
priz = line( buf, 50, 50, 50, 10,  170, 170, 170 );
priz = line( buf, -50, 40, 150, 40,  0, 0, 0 );


priz = krug( buf, 50, 50, 10,   0,  0,  0 );
priz = krug( buf, 50, 50, 20,  10, 10, 10 );
priz = krug( buf, 50, 50, 30,  20, 20, 20 );
priz = krug( buf, 50, 50, 40,  30, 30, 30 );
priz = krug( buf, 50, 50, 50,  40, 40, 40 );
priz = krug( buf, 50, 50, 60,  50, 50, 50 );
priz = krug( buf, 50, 50, 70,  60, 60, 60 );
priz = krug( buf, 110, 100, 40, 0, 0, 0 );

priz = krug( buf, 50, 100,  20, 0, 0, 0 );
priz = krug( buf, 50, 100,  30, 0, 0, 0 );
priz = krug( buf, 50, 100,  40, 0, 0, 0 );
priz = krug( buf, 50, 100,  50, 0, 0, 0 );
priz = krug( buf, 50, 100,  60, 0, 0, 0 );
priz = krug( buf, 50, -20, 80, 0, 0, 0 );
priz = krug( buf, 50, 100,  80, 0, 0, 0 );
priz = krug( buf, 50, 100,  90, 0, 0, 0 );
priz = krug( buf, 50, 100, 100, 0, 0, 0 );
priz = krug( buf, 50, 100, 110, 0, 0, 0 );
priz = krug( buf, 50, 100, 120, 0, 0, 0 );

priz = ellips( buf, 50,50,  40,20,   0, 0,0,0 );
priz = ellips( buf, 50,50,  20,40,  20, 0,0,0 );

priz = ellips( buf, 50,50,  40,20, 235,  0,0,0 );
priz = ellips( buf, 50,50,  20,40,  20, 0,0,0 );
priz = ellips( buf, 50,50,  20,40,  30, 0,0,0 );
priz = ellips( buf, 50,50,  20,40,  40, 0,0,0 );


priz = duga( buf,  0,10,  5,60,  7,94,  0,0,0 );
priz = duga( buf,  5,12.5,  10,40,  20,170,  0,0,0 );
priz = duga( buf,  0,10,  50,60,  100,5,  0,0,0 );
priz = duga( buf,  0,10,  50,60,  100,5,  0,0,0 );

priz = point( buf,   0, 10, 0, 255, 0 );
priz = point( buf,  50, 60, 0, 255, 0 );
priz = point( buf, 100,  5, 0, 255, 0 );

priz =  duga( buf,   0,  20,  50,50,  1,100,  0,0,0 );

priz = point( buf,   0,  20,  0, 255, 0 );
priz = point( buf,  50,  50,  0, 255, 0 );
priz = point( buf,   1, 100,  0, 255, 0 );



// Тестирование функции "save_bmp()" - Функции сохранения BMP - файла
priz = save_bmp("ris2.bmp", buf );

// Выдать возвращаемое значение
printf("\n priz =  %d   ",priz );


priz = open_bmp( "ris2.bmp", &buf);

// Выдать возвращаемое значение
printf("\n priz =  %d   ",priz );


return 0;

}

*/

