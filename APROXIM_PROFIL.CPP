// Апроксимация профиля дорожки качения наружного или внутреннего кольца рядом Фурье
#include "Graphika_bmp.cpp"

double pi = 3.1416;		// Консттанта ПИ = 3.1416

FILE	* f1;				// Дескриптор файла из которого считываются исходные данные.
FILE	* f2;				// Дескриптор файла в который записывают результаты расчета



////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////// Функция которая выполняет построение производной ряда Фурье	////////////////////
///
///		Входные параметры :		a - Указатель на массив содержащий коэффициенты ряда Фурье
///
///						a[0] - Свободный член      
///						a[1] - ????	
///
///						a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///						a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///						a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///						a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///
///						a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///						a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///						. . . . . . . . . .
///
///						a[2*N-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///						a[2*N-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///
///						N - Количество отсчетов на интервале разложения функции в ряд Фурье
///
///
///		Выходные параметры :	a_proizvod - Указатель на массив содержащий коэффициенты ряда Фурье являющегося 
///						     производной ряда Фурье заданного во входных параметрах
///
///	  Возвращаемое значение :	Нет
///
///

void fure_proizvod( double * a, int N, double * a_proizvod ) 
{
	int k;			// Счётчик цикла

	a_proizvod[0] = 0.0;	// Производная постоянной составляющей равна 0.
	a_proizvod[1] = 0.0;	// Не используемый элемент установить в 0.


	// Перебор в цикле всех гармоник
	for (k=1; k<N/2; k++) 
	{
		a_proizvod[2*k]		= a[2*k+1] * 2*pi * (double) k / (double) N;			// Получение коэффициента при cos() гармоники № k
		a_proizvod[2*k+1]	= a[2*k]   * 2*pi * (double) k / (double) N * (-1);		// Получение коэффициента при sin() гармоники № k
	}

	return;		// Выход из функции
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////  ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ СУММУ РЯДА ФУРЬЕ	////////////////////////////////////////
///
///		Входные параметры :	a - Указатель на массив содержащий коэффициенты ряда Фурье
///
///					a[0] - Свободный член      
///					a[1] - ????	
///
///					a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///					a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///					a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///					a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///                                     
///					a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///					a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///					. . . . . . . . . .
///
///					a[2*MAX_SIZE_OBR-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///					a[2*MAX_SIZE_OBR-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///
///					N - Количество отсчетов на интервале разложения функции в ряд Фурье
///
///					X1 - Номер отсчета для которого надо найти сумму ряда Фурье
///								
///
///		Выходные паараметры :	Нет	
///
///	  Возвращаемое значение :	Сумма ряда Фурье для отсчёта № X1
///
///

double fure(double * a, int N, int X1 )
{

int k;		// Счетчик цикла
double S;	// Сумма ряда Фурье

// Подсчет суммы ряда Фурье для отсчета X1
S=0.0;
S += a[0]/2.0;
for (k=1; k<N/2; k++) S += (a[k*2] * cos(2*pi* (double) k / (double) N * (double) X1 ) + a[k*2+1] * sin(2*pi* (double) k / (double) N * (double) X1) );


// Выход из функции с возвратом найденной суммы ряда Фурье
return S;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////  ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ НЕПОЛНУЮ СУММУ РЯДА ФУРЬЕ	////////////////////////////////
///
///		Входные параметры :	a - Указатель на массив содержащий коэффициенты ряда Фурье
///
///					a[0] - Свободный член      
///					a[1] - ????	
///
///					a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///					a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///					a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///					a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///
///					a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///					a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///					. . . . . . . . . .
///
///					a[2*MAX_SIZE_OBR-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///					a[2*MAX_SIZE_OBR-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///                                              
///					N1 - Количество гармоник используемых при суммировании ряд Фурье (0вая гармоник не в счет)
///					N  - Количество отсчетов на интервале разложения функции в ряд Фурье
///
///					X1 - Номер отсчета для которого надо найти сумму ряда Фурье
///								
///
///		Выходные паараметры :	Нет	
///
///	  Возвращаемое значение :	Сумма ряда Фурье в точке с координатой FI 		
///
///

double fure_nepoln(double * a, int N1, int N,  int X1 )
{

int k;		// Счетчик цикла
double S;	// Сумма ряда Фурье

// Подсчет неполной суммы ряда Фурье для отсчета X1
S=0.0;
S += a[0]/2.0;
for (k=1; k<N1; k++) S += (a[k*2] * cos(2*pi* (double) k / (double) N * (double) X1 ) + a[k*2+1] * sin(2*pi* (double) k / (double) N * (double) X1) );


// Выход из функции с возвратом найденной суммы ряда Фурье
return S;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////  ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ НЕПОЛНУЮ СУММУ РЯДА ФУРЬЕ	////////////////////////////////
///
///		Входные параметры :	a - Указатель на массив содержащий коэффициенты ряда Фурье
///
///					a[0] - Свободный член      
///					a[1] - ????	
///
///					a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///					a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///					a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///					a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///
///					a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///					a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///					. . . . . . . . . .
///
///					a[2*MAX_SIZE_OBR-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///					a[2*MAX_SIZE_OBR-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///                                              
///					N1 - Количество гармоник используемых при суммировании ряд Фурье (0вая гармоник не в счет)
///					N  - Количество отсчетов на интервале разложения функции в ряд Фурье
///
///					FI - Угловая координата
///								
///
///		Выходные паараметры :	Нет	
///
///	  Возвращаемое значение :	Сумма ряда Фурье в точке с координатой FI 		
///
///

double fure_nepoln_1(double * a, int N1, int N,  double FI )
{

int k;		// Счетчик цикла
double S;	// Сумма ряда Фурье

// Подсчет неполной суммы ряда Фурье для угла FI
S=0.0;
S += a[0]/2.0;
for (k=1; k<N1; k++) S += (a[k*2] * cos(FI * (double) k) + a[k*2+1] * sin(FI * (double) k));


// Выход из функции с возвратом найденной суммы ряда Фурье
return S;

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////	ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ РАДИУС КРИВИЗНЫ СПОСОБОМ № 1	////////////////////////////////////////////
///
///		Входные параметры :	a - Указатель на массив содержащий коэффициенты ряда Фурье
///						
///					a_proizvod_1	- Указатель на массив содержащий коэффициенты первой производной ряда Фурье
///
///					a_proizvod_2	- Указатель на массив содержащий коэффициенты второй производной ряда Фурье
///
///					N1		- Количество гармоник используемых при суммировании ряд Фурье (0 вая гармоник не в счет)
///
///					N		- Количество отсчетов на интервале разложения функции в ряд Фурье
///						
///					X1		- Номер отсчета для которого надо найти кривизну
///
///
///		Выходные паараметры :	Нет	
///
///
///	      Возвращаемое значение :	Радиус кривизны кривой задаваемой рядом Фурье для отсчёта X1 		
///	

double R_krivisna( double * a, double * a_proizvod_1, double * a_proizvod_2, int N1, int N, int X1 )
{
	double S;		// Сумма ряда Фурье
	double S_proizvod_1;	// Сумма первой производной ряда Фурье
	double S_proizvod_2;	// Сумма второй производной ряда Фурье
	double R_kriv;		// Радиус кривизны

	S		=	fure_nepoln(a, N1, N, X1);		// Найти сумму ряда Фурье в точке X1.
	S_proizvod_1	=	fure_nepoln(a_proizvod_1, N1, N, X1);	// Найти сумму первой производной ряда Фурье в точке X1.
	S_proizvod_2	=	fure_nepoln(a_proizvod_2, N1, N, X1);	// Найти сумму второй производной ряда Фурье в точке X1.

	R_kriv = step(S_proizvod_1*S_proizvod_1 + S*S,1.5) / ( S*S + 2*S_proizvod_1*S_proizvod_1 - S_proizvod_2*S);

	return R_kriv;			// Выход из функции с возвратом найденного радиуса кривизны
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////	ФУНКЦИЯ ВЫЧИСЛЯЮЩАЯ РАДИУС КРИВИЗНЫ СПОСОБОМ № 2	/////////////////////////////////
///
///                        		
///		Входные параметры :	a - Указатель на массив содержащий коэффициенты ряда Фурье
///
///					N1 - Количество гармоник используемых при суммировании ряд Фурье (0 вая гармоник не в счет)
///
///					N  - Количество отсчетов 
///						
///					X1 - Номер отсчета для которого надо найти кривизну

double R_krivisna2( double * a, int N1, int N, int X1 )
{
	double	dFI;		/// Угловая шаг в радианах

	double FI_00;		/// Текущий угол в радианах
	double FI_m1;		/// Текущий угол - угловой шаг
	double FI_m2;		/// Текущий угол - 2 угловых шага
	double FI_m3;		/// Текущий угол - 3 угловых шага
	double FI_01;		/// Текущий угол + угловой шаг
	double FI_02;		/// Текущий угол + 2 угловых шага
	double FI_03;		/// Текущий угол + 3 угловых шага

	double S, R_00;		/// Радиус соответствующий текущему углу
	double R_m1;		/// Радиус соответствующий текущему углу - угловой шаг
	double R_m2;		/// Радиус соответствующий текущему углу - 2 угловых шага
	double R_m3;		/// Радиус соответствующий текущему углу - 3 угловых шага 
	double R_01;		/// Радиус соответствующий текущему углу + угловой шаг
	double R_02;		/// Радиус соответствующий текущему углу + 2 угловых шага
	double R_03;		/// Радиус соответствующий текущему углу + 3 угловых шага

	double X_00, Y_00;	/// Координаты X,Y точки соответствующей текущему углу
	double X_m1, Y_m1;	/// Координаты X,Y точки соответствующей текущему углу - угловой шаг
	double X_m2, Y_m2;	/// Координаты X,Y точки соответствующей текущему углу - 2 угловых шага
	double X_m3, Y_m3;	/// Координаты X,Y точки соответствующей текущему углу - 3 угловых шага

	double X_01, Y_01;	/// Координаты X,Y точки соответствующей текущему углу + угловой шаг
	double X_02, Y_02;	/// Координаты X,Y точки соответствующей текущему углу + 2 угловых шага
	double X_03, Y_03;	/// Координаты X,Y точки соответствующей текущему углу + 3 угловых шага

	double F_1_proizvod;	/// Первая производная
	double F_2_proizvod;	/// Вторая производная

	double R_kriv;		///  Радиус кривизны 




	dFI 	=  2 * pi / (double) N / 10000.0;		/// Определить угловой шаг в радианах	
//	dFI 	=  2 * pi / (double) N / 100.0;		/// Определить угловой шаг в радианах	



	FI_00 	=  2 * pi * (double) X1 / (double) N;	/// Определить текущий угол в радианах
	FI_m1 	= FI_00 - dFI;	                        /// Определить текущий угол в радианах - угловой шаг
	FI_m2 	= FI_00 - 2*dFI;	                /// Определить текущий угол в радианах - 2 угловых шага
	FI_m3 	= FI_00 - 3*dFI;	                /// Определить текущий угол в радианах - 3 угловых шага
	FI_01 	= FI_00 + dFI;                          /// Определить текущий угол в радианах + угловой шаг
	FI_02 	= FI_00 + 2*dFI;	                /// Определить текущий угол в радианах + 2 угловых шага
	FI_03 	= FI_00 + 3*dFI;	                /// Определить текущий угол в радианах + 3 угловых шага

	R_00 	= fure_nepoln_1(a, N1, N, FI_00);	/// Определить радиус соответствующий текущему углу
	R_m1	= fure_nepoln_1(a, N1, N, FI_m1);	/// Определить радиус соответствующий текущему углу - угловой шаг
	R_m2	= fure_nepoln_1(a, N1, N, FI_m2);	/// Определить радиус соответствующий текущему углу - 2 угловых шага
	R_m3	= fure_nepoln_1(a, N1, N, FI_m3);	/// Определить радиус соответствующий текущему углу - 3 угловых шага
	R_01	= fure_nepoln_1(a, N1, N, FI_01);	/// Определить радиус соответствующий текущему углу + угловой шаг
	R_02	= fure_nepoln_1(a, N1, N, FI_02);	/// Определить радиус соответствующий текущему углу + 2 угловых шага
	R_03	= fure_nepoln_1(a, N1, N, FI_03);	/// Определить радиус соответствующий текущему углу + 3 угловых шага



	X_00 = R_00 * cos(FI_00);	/// Координата X точки соответствующей текущему углу
	Y_00 = R_00 * sin(FI_00);	/// Координата Y точки соответствующей текущему углу

	X_m1 = R_m1 * cos(FI_m1);	/// Координата X точки соответствующей текущему углу - угловой шаг
	Y_m1 = R_m1 * sin(FI_m1);	/// Координата Y точки соответствующей текущему углу - угловой шаг

	X_m2 = R_m2 * cos(FI_m2);	/// Координата X точки соответствующей текущему углу - 2 угловых шага
	Y_m2 = R_m2 * sin(FI_m2);	/// Координата Y точки соответствующей текущему углу - 2 угловых шага

	X_m3 = R_m3 * cos(FI_m3);	/// Координата X точки соответствующей текущему углу - 3 угловых шага
	Y_m3 = R_m3 * sin(FI_m3);	/// Координата Y точки соответствующей текущему углу - 3 угловых шага


	X_01 = R_01 * cos(FI_01);	/// Координата X точки соответствующей текущему углу + угловой шаг
	Y_01 = R_01 * sin(FI_01);	/// Координата Y точки соответствующей текущему углу + угловой шаг

	X_02 = R_02 * cos(FI_02);	/// Координата X точки соответствующей текущему углу + 2 угловых шага
	Y_02 = R_02 * sin(FI_02);	/// Координата Y точки соответствующей текущему углу + 2 угловых шага

	X_03 = R_03 * cos(FI_03);	/// Координата X точки соответствующей текущему углу + 3 угловых шага
	Y_03 = R_03 * sin(FI_03);	/// Координата Y точки соответствующей текущему углу + 3 угловых шага

	F_1_proizvod = (Y_m1 - Y_01) / ( X_m1 - X_01);								/// Вычисление первой производной
	F_2_proizvod = 2.0/fabs(X_m1 - X_01)  * ( ((Y_m1-Y_00)/(X_m1-X_00)) - ((Y_00-Y_01)/(X_00-X_01)) );		/// Вычисление второй производной
	R_kriv =  step( 1.0 + F_1_proizvod*F_1_proizvod , 1.5 )	/ F_2_proizvod;					/// Вычисление радиуса кривизны кривой 

	

	S  = fure_nepoln(a, N1, N, X1);		/// Найти сумму ряда Фурье в точке X1.


//	printf("\n  Iz    R_krivisna_2 :      X1 = %3d     FI_00 =  %15.8f    S = %15.8f   R_00 = %15.8f   ", X1, FI_00, S, R_00  );

	printf("\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
	printf("\n  FI_m1 = %15.8f        R_m1 = %15.8f      X_m1 = %15.8f      Y_m1 = %15.8f    ", FI_m1, R_m1, X_m1, Y_m1);
	printf("\n  FI_00 = %15.8f        R_00 = %15.8f      X_00 = %15.8f      Y_00 = %15.8f    ", FI_00, R_00, X_00, Y_00);
	printf("\n  FI_01 = %15.8f        R_01 = %15.8f      X_01 = %15.8f      Y_01 = %15.8f    ", FI_01, R_01, X_01, Y_01);
	printf("\n  F_1_proizvod = %15.8f                    F_2_proizvod = %15.8f           R_kriv = %15.8f       ", F_1_proizvod, F_2_proizvod, R_kriv); 
	printf("\n  Ugol v gradusah = %15.8f           R_kriv = %15.8f       ", FI_00 * 180/pi, R_kriv); 
	printf("\n");

	fprintf(f2,"\n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -");
	fprintf(f2,"\n  FI_m1 = %15.8f        R_m1 = %15.8f      X_m1 = %15.8f      Y_m1 = %15.8f    ", FI_m1, R_m1, X_m1, Y_m1);
	fprintf(f2,"\n  FI_00 = %15.8f        R_00 = %15.8f      X_00 = %15.8f      Y_00 = %15.8f    ", FI_00, R_00, X_00, Y_00);
	fprintf(f2,"\n  FI_01 = %15.8f        R_01 = %15.8f      X_01 = %15.8f      Y_01 = %15.8f    ", FI_01, R_01, X_01, Y_01);
	fprintf(f2,"\n  F_1_proizvod = %15.8f                F_2_proizvod = %15.8f            R_kriv = %15.8f       ", F_1_proizvod, F_2_proizvod, R_kriv); 
	fprintf(f2,"\n  Угол в градусах = %15.8f           R_kriv = %15.8f       ", FI_00 * 180/pi, R_kriv); 
	fprintf(f2,"\n - - - -");


	fprintf(f2,"\n  fabs(2.0/(X_m1 - X_01)) = %15.12f           ( ((Y_m1-Y_00)/(X_m1-X_00)) - ((Y_00-Y_01)/(X_00-X_01)) ) = %15.12f       ((Y_m1-Y_00)/(X_m1-X_00)) = %15.12f         ((Y_00-Y_01)/(X_00-X_01)) = %15.12f        ", fabs(2.0/(X_m1 - X_01)),  (((Y_m1-Y_00)/(X_m1-X_00)) - ((Y_00-Y_01)/(X_00-X_01))), ((Y_m1-Y_00)/(X_m1-X_00)), ((Y_00-Y_01)/(X_00-X_01))                  ); 


	fprintf(f2,"\n");


	return  R_kriv;		/// Выход из функции с возвратом найденной кривизны
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////    ФУНКЦИЯ ВЫПОЛНЯЮЩАЯ БЫСТРОЕ ПРЕОБРАЗОВАНИЕ ФУРЬЕ    //////////////////////////////////////////////////////////////////
///
///		Входные параметры :		a - 	Указатель на массив содержащий отсчеты исходной последовательности 
///							предназначенной для преобразованимя Фурье
///
///						a[0] = Отсчет № 0   
///						a[1] = 0.0
///
///						a[2] = Отсчет № 1   
///						a[3] = 0.0
///
///						a[4] = Отсчет № 2   
///						a[5] = 0.0
///
///						a[6] = Отсчет № 3   
///						a[7] = 0.0
///
///						. . . . . . . . . .
///
///						a[2*MAX_SIZE_OBR-2] = Отсчет № N-1   
///						a[2*MAX_SIZE_OBR-1] = 0.0
///
///		
///						MAX_SIZE_OBR - Количество отсчетов 
///		
///						
///		Выходные параметры :		a - Указатель на массив содержащий результаты БПФ (коэффициенты ряда Фурье)	
///
///						a[0] - Свободный член      
///						a[1] - ????	
///
///						a[2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 1 )
///						a[3] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 1 )	
///		
///						a[4] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 2 )
///						a[5] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 2 )	
///
///						a[6] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * 3 )
///						a[7] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * 3 )	
///		
///						. . . . . . . . . .
///
///						a[2*MAX_SIZE_OBR-2] - Коэффициент при cos( 2 * pi / MAX_SIZE_OBR * f * (N-1) )
///						a[2*MAX_SIZE_OBR-1] - Коэффициент при sin( 2 * pi / MAX_SIZE_OBR * f * (N-1) )	
///
///
///	Возвращаемое значекние	:	Нет
///
///


void bpf( double * a, unsigned long MAX_SIZE_OBR)
{

double drob_chast_kol_etapov, kol_etapov_double;
unsigned long kol_etap, j, m, i, k, nom_etap, razm_uchast, pol_razm_uchast, kol_uchast, nom_uchast, ukaz_el1, ukaz_el2 ; 
double a0, a1, pi_2_del_razm_uchast, pi_2_k_del_razm_uchast;

// Определить число этапов БПФ.
drob_chast_kol_etapov = modf(log(MAX_SIZE_OBR)/log(2.0),&kol_etapov_double);
kol_etap= (unsigned long) kol_etapov_double;
if (drob_chast_kol_etapov>0.98) kol_etap++;


// Выполнить двоично-инверсную перестановку элементов массива a[][] содержащего входную последовательность.
j=0;
m = (unsigned long) MAX_SIZE_OBR/2;

for (i=0; i<MAX_SIZE_OBR; i++)
{
	if (j>i)
	{
		a0= *(a+j*2);
		*(a+j*2) = *(a+i*2);
		*(a+i*2) = a0; 
	}

	k=m;

	while ((j>=k) && !((j==0)&&(k==0)))
	{
		j-=k;
		k/=2;
	}

	j+=k;
}


// Выполнить БПФ над последовательностью записанной в массиве a[][].
for (nom_etap=1, razm_uchast=2; nom_etap<=kol_etap; nom_etap++, razm_uchast*=2)
{
	pol_razm_uchast=razm_uchast/2;
	kol_uchast=MAX_SIZE_OBR/razm_uchast;
	pi_2_del_razm_uchast= (double) pi /(double) razm_uchast * 2;

	for (nom_uchast=0; nom_uchast<kol_uchast; nom_uchast++)
	{
		for (k=0,ukaz_el2=nom_uchast*razm_uchast+pol_razm_uchast; k<pol_razm_uchast; k++, ukaz_el2++)
		{
			pi_2_k_del_razm_uchast= pi_2_del_razm_uchast*k;
			a0= *(a+ukaz_el2*2);
			*(a+ukaz_el2*2) = *(a+ukaz_el2*2)* cos(pi_2_k_del_razm_uchast)+ *(a+ukaz_el2*2+1)* sin(pi_2_k_del_razm_uchast);
			*(a+ukaz_el2*2+1) = *(a+ukaz_el2*2+1)*cos(pi_2_k_del_razm_uchast)-a0*sin(pi_2_k_del_razm_uchast);
		}

		for (k=0,ukaz_el1=nom_uchast*razm_uchast,ukaz_el2=ukaz_el1+pol_razm_uchast; k<pol_razm_uchast; k++,ukaz_el1++,ukaz_el2++)
		{
			a0 = *(a+ukaz_el1*2);
			a1 = *(a+ukaz_el1*2+1);
			*(a+ukaz_el1*2) += *(a+ukaz_el2*2);
			*(a+ukaz_el1*2+1) += *(a+ukaz_el2*2+1);
			*(a+ukaz_el2*2) = a0 - *(a+ukaz_el2*2);
			*(a+ukaz_el2*2+1) = a1 - *(a+ukaz_el2*2+1);
		}
	}
}


// Найденные  коэффициенты ряда Фурье разделить на MAX_SIZE_OBR и MAX_SIZE_OBR/2
for (i=0; i< MAX_SIZE_OBR/2; i++)
{
	a[i*2]	 =  2.0 * a[i*2]   / (double) MAX_SIZE_OBR ;
	a[i*2+1] = -2.0 * a[i*2+1] / (double) MAX_SIZE_OBR ;
}

return;		// Выход из процедуры БПФ

}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////		ГЛАВНАЯ  ФУНКЦИЯ			/////////////////////////////////////////////// 
	
int main( int argc, char * argv[] )
{

///FILE	* f1;				// Дескриптор файла из которого считываются исходные данные.
///FILE	* f2;				// Дескриптор файла в который записывают результаты расчета

char	c1;				// Считанный символ

int	N;				// Количество точек на окружности описывающий профиль
int	N1;				// Количество гармоник (не считая 0 вую) используемых для суммирования ряда Фурье

int	i;				// Счетчик цикла
int	k;				// Счетчик цикла

char	* stroka;			// Указатель на область памяти в которую записывается строка.
int	dl_stroka;			// Длина строки считанной из файла исходных данных

double	* float_value;			// Указатель на массив вещественных значений прочитанных из строки.
int	kol_float_value;		// Количество вещественных значений прочитанных из строки.

double		* profil;		// Указатель на массив вещественных значений описывающий профиль дорожки качения кольца				
double		* aa;			// Указатель на массив вещественных значений в который записываются коэффициенты ряда Фурье
double		* sum_fure;		// Указатель на массив вещественных значения хранящий сумму ряда Фурье описывающий профиль дорожки качения
unsigned long	* X1_Array;		// Указатель на массив координат Х1 точек изображаемых на графике
unsigned long	* X2_Array;		// Указатель на массив координат Х1 точек изображаемых на графике
unsigned long	* Y1_Array;		// Указатель на массив координат Y1 точек изображаемых на графике
unsigned long	* Y2_Array;		// Указатель на массив координат Y2 точек изображаемых на графике

double	* R_kriv;			// Указатель на массив вещественных значений описывающих радиус кривизны дорожки качения вычисленный способом № 1
double	* a_proizvod_1;			// Указатель на массив вещественных значений хранящий коэффициенты 1 ой производной ряда Фурье
double	* a_proizvod_2;			// Указатель на массив вещественных значений хранящий коэффициенты 2 ой производной ряда Фурье

/////////////////////////////////////////////////////////////////////////////////////////
///

double	* R_kriv2;			// Указатель на массив вещественных значений описывающих радиус кривизны дорожки качения вычисленный способом № 2

///
/////////////////////////////////////////////////////////////////////////////////////////


double tek_ugol_gradus;			// Текущий угол в градусах
double tek_ugol_radian;			// Текущий угол в радианвх

char char_sign_1, char_sign_2;		// Символьное представление знака вещественного числа

int priz;				// Признак удачного выполнения
unsigned char * buf_rezult_graph;	// Указатель на буфер в который помещается BMP - файл содержащий графическое отображение результатов 

unsigned long X_max;			// Размер изображения в пикселях по горизонтали
unsigned long Y_max;			// Размер изображения в пикселях по вертикали

unsigned long X_centr;			// Координата центра изображения по горизонтали	
unsigned long Y_centr;			// Координата центра изображения по вертикали

double R_pix;				// Радиус дорожки качения в пикселях
double R_max;				// Максимальнвй радиус дорожки качения

double K1;				// Коэффициент преобразования используемый при рисовании профиля дорожки качения



X_max = 1000;		// Задать размер изображения в пикселях по горизонтали
Y_max = 1000;		// Задать размер изображения в пикселях по вертикали


// Выделить область памяти объемом 100 байт для чтения строки.
stroka = (char *) malloc(100 * sizeof(char));
if (stroka == NULL)
{
	// Неудача при выделении памяти объемом 100 байт для хранения разделительной строки. 		
	printf("\n Oshibka - Neudacha pri wydelenii pamyati 100 byte. ");	// Выдать сообщение об ошибке.
	return -1;								// Выход из программы с признаком неудачи
}


// Открыть файл для чтения исходных данных.
if ( (f1=fopen("PROF_NK.DAT","r")) == NULL )
{
	// Неудача при открытии файла для чтения исходных данных. 
	free(stroka);							// Освободить ранее выделенный блок памяти под хранение строки
	printf("\n  Oshibka - File  PROF_NK.DAT ne naiden !!! ");	// Выдать сообщение об ошибке.
	return -1;							// Завершить работу программы с признаком ошибки.
}


// Чтение исходных данных о профиле дорожки качения кольца
// и подсчет количества точек описывающих профиль.
N=0;
fseek(f1,0L,SEEK_SET);							// Переход на начало файла исходных данных
while (!feof(f1))
{
	// Переписать в переменную "stroka" очередную строку файла исходных данных
	c1=0;
	i=0;
	while((!feof(f1)) && (c1!=10))
	{
		c1 = getc(f1);
		*(stroka+i) = c1;
		i++;
	}
	*(stroka+i) = '\0';
	dl_stroka = i;								// Запомнить длину строки считаной из файла исходных данных
	kol_float_value = string_float(stroka, dl_stroka, &float_value);	// Получить массив вещественных чисел из очередной строки файла исходных данных.

	if (kol_float_value > 0)
	{
		// Из текущей строки файла исходных данных получены вещественные значения.
		// Нарастить счетчик считанных вещественных значений
		N++;
	}

	free(float_value);							// Освободить область памяти выделенную для хранения массива вещественных чисел.
}



// Выделить память под массив описывающий профиль 
profil = (double *) malloc(N*sizeof(double));
if (profil == NULL)
{
	// Неудача при выделении памяти для хранения массива описывающего профиль дорожки качения кольца
	free(stroka);								// Освободить ранее выделенный блок памяти под хранение строки.
	fclose(f1);								// Закрыть файл из которого прочитаны исходные данные.
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva profil !!! ");	// Выдать сообщение об ошибке.
	return -1;								// Завершить работу программы с признаком ошибки.
}



// Чтение исходных данных о профиле дорожки качения кольца.
k=0;
fseek(f1,0L,SEEK_SET);								// Переход на начало файла исходных данных
while (!feof(f1))
{
	// Переписать в переменную "stroka" очередную строку файла исходных данных
	c1=0;
	i=0;
	while((!feof(f1)) && (c1!=10))
	{
		c1 = getc(f1);
		*(stroka+i) = c1;
		i++;
	}
	*(stroka+i) = '\0';
	dl_stroka = i;								// Запомнить длину строки считаной из файла исходных данных
	kol_float_value = string_float(stroka, dl_stroka, &float_value);	// Получить массив вещественных чисел из очередной строки файла исходных данных.

	if (kol_float_value > 0)
	{
		// Из текущей строки файла исходных данных получены вещественные значения.
		*(profil+k) = *(float_value+0);		// Запомнить полученное вещественное значение в массиве описывающем профиль дорожки качения наружного кольца
		k++;
	}

	free(float_value);							// Освободить область памяти выделенную для хранения массива вещественных чисел.
}


// Выделить область памяти для хранения массива "aa[]" который используется для получения коэффициентов Фурье
aa = (double *) malloc(N*2*sizeof(double));
if (aa == NULL)
{
	// Неудача при выделении памяти для хранения массива коэффициентов Фурье
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva profil !!! ");		// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}

if ((f2=fopen("REZULT.DAT","w")) == NULL )
{
	// Неудача при попытке создать файл                                             
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	printf("\n   Oshibka pri sozdanii file REZULT.DAT");				// Выдать сообщение об ошибке
	return -1;									// Завершить работу программы с признаком ошибки.
}

if (argc == 2)
{
	// В командной строке задано максимальное количество гармоник используемых при суммировании ряда Фурье
	N1 = atoi( argv[1] );		// Считать максимальное количество гармоник используемых при суммировании ряда Фурье
}
else
{
	// В командной строке не задано максимальное количество гармоник используемых при суммировании ряда Фурье
	N1 = N/2;			// Количество гармоник используемых при суммировании ряда Фурье на половине от количества отсчетов
}


// Выдать на экран считанный профиль дорожки качения кольца
fprintf(f2,"\n                                                    ");
fprintf(f2,"\n         ИСХОДНЫЙ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ           ");
fprintf(f2,"\n                                                    ");
fprintf(f2,"\n -------------------------------------------------- ");
fprintf(f2,"\n | № отсчета  | Угол в градусах   |  Радиус в мм  | ");
fprintf(f2,"\n -------------------------------------------------- ");

for (k=0; k<N; k++)
{
	tek_ugol_gradus = 360.0 * (double) k / (double) N;
	fprintf(f2,"\n |    %4d    |  %10.3f       | %13.8f |", k, tek_ugol_gradus, *(profil+k));
}

fprintf(f2,"\n -------------------------------------------------- ");
fprintf(f2,"\n                                                    ");
fprintf(f2,"\n                                                    ");


// Копирование массива profil[] в массив aa[]
for (k=0; k<N; k++)
{
	*(aa+k*2)   = *(profil+k);
	*(aa+k*2+1) = 0.0;
}

// Выполнение БПФ
bpf(aa, N);

// Выдать результаты БПФ
fprintf(f2,"\n ---------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n                                                    ");
fprintf(f2,"\n   РЯД ФУРЬЕ ОПИСЫВАЮЩИЙ ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ    ");
fprintf(f2,"\n                                                    ");
fprintf(f2,"\n Результат( k ) =  %15.8f ", aa[0]/2.0 );

for (k=1; k<N/2; k++)
{
	if (aa[k*2] >= 0) 
	{
		char_sign_1 = '+';
	}
	else
	{
		char_sign_1 = '-';
	}

	if (aa[k*2+1] >= 0) 
	{
		char_sign_2 = '+';
	}
	else
	{
		char_sign_2 = '-';
	}
	
	fprintf(f2,"\n                    %c%13.8f * cos( 2*pi/%3d * k *%3d ) %c%13.8f * sin( 2*pi/%3d * k *%3d ) ", char_sign_1, fabs(aa[k*2]), N, k,   char_sign_2, fabs(aa[k*2+1]), N, k);
}


// Выделить область памяти для хранения массива "sum_fure[]" суммы ряда Фурье описывающего профиль дорожки качения кольца
sum_fure = (double *) malloc(N*sizeof(double));
if (sum_fure == NULL)
{
	// Неудача при выделении области памяти для хранения массива "sum_fure[]"
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva sum_fure[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}


// Записать в массив "sum_fure[]" сумму ряда Фурье для всех точек профиля
for (k=0; k<N; k++)
{
	*(sum_fure+k) = fure_nepoln( aa, N1, N, k);
}

// Выделить область памяти для массива координат Х точек изображаемых на графике
X1_Array = (unsigned long *) malloc( (N+1)*sizeof(unsigned long));
if (X1_Array == NULL)
{
	// Неудача при выделении области памяти для хранения массива координа X1 точек изображаемых на графике
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva X1_Array[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}


// Выделить область памяти для массива координат Х2 точек изображаемых на графике
X2_Array = (unsigned long *) malloc( (N+1)*sizeof(unsigned long));
if (X1_Array == NULL)
{
	// Неудача при выделении области памяти для хранения массива координа X точек изображаемых на графике
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva X1_Array[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}


// Выделить область памяти для массива координат Y1 точек изображаемых на графике
Y1_Array = (unsigned long *) malloc( (N+1)*sizeof(unsigned long));
if (Y1_Array == NULL)
{
	// Неудача при выделении области памяти для хранения массива координа Y1 точек изображаемых на графике
	free(X2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X2_Array"
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"	
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva Y1_Array[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}


// Выделить область памяти для массива координат Y2 точек изображаемых на графике
Y2_Array = (unsigned long *) malloc( (N+1)*sizeof(unsigned long));
if (Y2_Array == NULL)
{
	// Неудача при выделении области памяти для хранения массива координа Y2 точек изображаемых на графике
	free(Y1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y1_Array"
	free(X2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X2_Array"
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"	
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva Y2_Array[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}


// Выделить область памяти для массива радиусов кривизны профиля дорожки качения рассчитанной способом № 1
R_kriv = (double *) malloc(N*sizeof(double));
if (R_kriv == NULL)
{
	// Неудача при выделении области памяти для хранения массива радиусов кривизны дорожки качения
	free(Y2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y2_Array"
	free(Y1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y1_Array"
	free(X2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X2_Array"
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"	
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva R_kriv[] !!! ");		// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}

// Выделить область памяти для массива коэффициентов первой производной ряда Фурье
a_proizvod_1 = (double *) malloc(N*2*sizeof(double));
if (a_proizvod_1 == NULL)
{
	// Неудача при выделении области памяти для массива коэффициентов первой производной ряда Фурье
	free(R_kriv);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "R_kriv"
	free(Y2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y2_Array"
	free(Y1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y1_Array"
	free(X2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X2_Array"
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"	
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva  a_proizvod_1[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}

// Выделить область памяти для массива коэффициентов второй производной ряда Фурье
a_proizvod_2 = (double *) malloc(N*2*sizeof(double));
if (a_proizvod_2 == NULL)
{
	// Неудача при выделении области памяти для массива коэффициентов второй производной ряда Фурье
	free(a_proizvod_1);								// Освободить ранее выделенный блок памяти выделенный под хранение массива "a_proizvod_1"
	free(R_kriv);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "R_kriv"
	free(Y2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y2_Array"
	free(Y1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y1_Array"
	free(X2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X2_Array"
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"	
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva  a_proizvod_2[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}

////////////////////////////////////////////////////////////////////////////////////////////////////
///

// Выделить область памяти для массива радиусов кривизны профиля дорожки качения рассчитанной способом № 2
R_kriv2 = (double *) malloc(N*sizeof(double));
if (R_kriv2  == NULL)
{
	// Неудача при выделении области памяти для массива радиусов кривизны профиля дорожки качения рассчитанной способом № 2
	free(a_proizvod_2);								// Освободить ранее выделенный блок памяти выделенный под хранение массива "a_proizvod_2"
	free(a_proizvod_1);								// Освободить ранее выделенный блок памяти выделенный под хранение массива "a_proizvod_1"
	free(R_kriv);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "R_kriv"
	free(Y2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y2_Array"
	free(Y1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "Y1_Array"
	free(X2_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X2_Array"
	free(X1_Array);									// Освободить ранее выделенный блок памяти выделенный под хранение массива "X1_Array"
	free(sum_fure);									// Освободить ранее выделенный блок памяти выделенный под хранения массива "sum_fure[]"	
	free(aa);									// Освободить ранее выделенный блок памяти выделенный под хранение массива aa[]
	free(stroka);									// Освободить ранее выделенный блок памяти выделенный под хранение строки.
	free(profil);									// Освободить ранее выделенный блок памяти выделенный под хранения профиля кольца
	fclose(f1);									// Закрыть файл из которого прочитаны исходные данные.
	fclose(f2);									// Закрыть файл в который записываются результаты расчетов
	printf("\n  Oshibka - Ne wydelena pamyat dlya massiva  a_proizvod_2[] !!! ");	// Выдать сообщение об ошибке.
	return -1;									// Завершить работу программы с признаком ошибки.
}

///
/////////////////////////////////////////////////////////////////////////////////////////////////////

// На основе массива коэффициентов ряда Фурье построение массива коэффициентов 1 ой производной ряда Фурье
fure_proizvod(aa, N, a_proizvod_1);

// Выдать в отчет 1 ую производную ряда Фурье
fprintf(f2,"\n ---------------------------------------------------------------------------------------------------- 	");
fprintf(f2,"\n														");
fprintf(f2,"\n   1 ая ПРОИЗВОДНАЯ РЯДА ФУРЬЕ ОПИСЫВАЮЩЕГО ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ    					");                
fprintf(f2,"\n														");
fprintf(f2,"\n 1 ая производная результата( k ) =  %15.8f ", a_proizvod_1[0]/2.0 );

for (k=1; k<N/2; k++)
{
	if (a_proizvod_1[k*2] >= 0) 
	{
		char_sign_1 = '+';
	}
	else
	{
		char_sign_1 = '-';
	}

	if (a_proizvod_1[k*2+1] >= 0) 
	{
		char_sign_2 = '+';
	}
	else
	{
		char_sign_2 = '-';
	}
	
	fprintf(f2,"\n                    %c%13.8f * cos( 2*pi/%3d * k *%3d ) %c%13.8f * sin( 2*pi/%3d * k *%3d ) ", char_sign_1, fabs(a_proizvod_1[k*2]), N, k,   char_sign_2, fabs(a_proizvod_1[k*2+1]), N, k);
}


// На основе массива коэффициентов 1 ой производной ряда Фурье построение массива коэффициентов 2 ой производной ряда Фурье
fure_proizvod( a_proizvod_1, N, a_proizvod_2);


// Выдать в отчет 2 ую производную ряда Фурье
fprintf(f2,"\n ---------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n																		 ");
fprintf(f2,"\n   2 ая ПРОИЗВОДНАЯ РЯДА ФУРЬЕ ОПИСЫВАЮЩЕГО ПРОФИЛЬ ДОРОЖКИ КАЧЕНИЯ    ");
fprintf(f2,"\n																		");
fprintf(f2,"\n 2 ая производная результата( k ) =  %15.8f ", a_proizvod_2[0]/2.0 );

for (k=1; k<N/2; k++)
{
	if (a_proizvod_2[k*2] >= 0) 
	{
		char_sign_1 = '+';
	}
	else
	{
		char_sign_1 = '-';
	}

	if (a_proizvod_2[k*2+1] >= 0) 
	{
		char_sign_2 = '+';
	}
	else
	{
		char_sign_2 = '-';
	}
	
	fprintf(f2,"\n                    %c%13.8f * cos( 2*pi/%3d * k *%3d ) %c%13.8f * sin( 2*pi/%3d * k *%3d ) ", char_sign_1, fabs(a_proizvod_2[k*2]), N, k,   char_sign_2, fabs(a_proizvod_2[k*2+1]), N, k);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///

/// Определение кривизны профиля дорожки качения 
for (k=0; k<N; k++)
{
	/// Определение кривизны профиля дорожки качения способом № 1 		
	*(R_kriv+k)  = R_krivisna( aa, a_proizvod_1, a_proizvod_2, N1, N, k );

	/// Определение кривизны профиля дорожки качения способом № 2 		
	*(R_kriv2+k) = R_krivisna2( aa, N1, N, k );	
}

/// Выдать исходный профиль дорожки качения, результат аппроксимации профиля с помощью ряда Фурье.
fprintf(f2,"\n												");
fprintf(f2,"\n   СРАВНЕНИЕ ИСХОДНОГО ПРОФИЛЯ ДОРОЖКИ КАЧЕНИЯ И ЕГО АПРОКСИМАЦИИ РЯДОМ ФУРЬЕ  		");
fprintf(f2,"\n												");
fprintf(f2,"\n ------------------------------------------------------------------------------------------------------ ");
fprintf(f2,"\n |            |                   |Радиус профиля | Апроксимация  | Радиус кривизны | Радиус кривизны | ");
fprintf(f2,"\n | № отсчета  | Угол в градусах   |дорожки качения|   профиля     | профиля дорожки | профиля дорожки |");
fprintf(f2,"\n |            |                   |     в мм      | рядом Фурье   |   качения в мм  |   качения в мм  | ");
fprintf(f2,"\n |            |                   |               |               |   способом № 1  |   способом № 2  |  ");
fprintf(f2,"\n ------------------------------------------------------------------------------------------------------- ");

for (k=0; k<N; k++)
{
	tek_ugol_gradus = 360.0  * (double) k / (double) N;															// Определить текущий угол в градусах
	tek_ugol_radian = 2 * pi * (double) k / (double) N;															// Определить текущий угол в радианах
	fprintf(f2,"\n |    %4d    |  %10.5f       | %13.8f | %13.8f | %13.8f |  %13.8f |  ", k, tek_ugol_gradus, *(profil+k), *(sum_fure+k), *(R_kriv+k), *(R_kriv2+k) );	// Выдать угол в градусах, радиус дорожки качения, сумму ряда Фурье, радиус кривизны
}

fprintf(f2,"\n ------------------------------------------------------------------------------------------------------- ");
fprintf(f2,"\n                                                                                      ");
fprintf(f2,"\n                                                                                      ");


///
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





X_centr = X_max/2;		// Определить координату центра изображения по горизонтали	
Y_centr	= Y_max/2;		// Определить координату центра изображения по вертикали

printf("\n  X_centr = %ld  Y_centr = %ld  ", X_centr, Y_centr);


// Определить радиус изображаемой дорожки качения в пикселях
if (X_centr < Y_centr)
{
	R_pix = X_centr * 0.9; 	
}
else
{
	R_pix = Y_centr * 0.9; 	 
}

printf("\n  R_pix = %12.5f   ", R_pix);


// Определить максимальный радиус дорожки качения
R_max = *(sum_fure+0);

for (k=1; k < N; k++)
{
	if (*(sum_fure+k) > R_max)
	{
		R_max = *(sum_fure+k);
	}
}

for (k=0; k < N; k++)
{
	if (*(profil+k) > R_max)
	{
		R_max = *(profil+k);
	}
}

printf("\n  R_max = %12.5f   ", R_max);



if ( R_max > 0 )
{
	// Дорожка качения задана
	K1 = R_pix / R_max;	// Определить коэффициент преобразования используемый при рисовании профиля дорожки качения

	// Формирование массивов координат Х, Y1, Y2 точек 	на графике
	for (k=0; k < N; k++)
	{
		*(X1_Array+k)  =  X_centr - (unsigned long)(*(profil+k) * K1 * cos(2*pi*k/N));
		*(Y1_Array+k)  =  Y_centr - (unsigned long)(*(profil+k) * K1 * sin(2*pi*k/N));
		
		*(X2_Array+k)  =  X_centr - (unsigned long)(*(sum_fure+k) * K1 * cos(2*pi*k/N));		
		*(Y2_Array+k)  =  Y_centr - (unsigned long)(*(sum_fure+k) * K1 * sin(2*pi*k/N));
	}

	*(X1_Array+N)  =  *(X1_Array+0);
	*(Y1_Array+N)  =  *(Y1_Array+0); 
		
	*(X2_Array+N)  =  *(X2_Array+0);
	*(Y2_Array+N)  =  *(Y2_Array+0);

	priz = create_bmp( X_max, Y_max, 255, 255, 255, &buf_rezult_graph );	// Создать в буфере памяти образ BMP-файла содержащего графическое представление результатов расчета

	// Нарисовать центр дорожки качения.
	priz = point( buf_rezult_graph, X_centr, Y_centr, 255, 0, 0 );			
	for (k=1; k<4;	k++) priz = krug( buf_rezult_graph, X_centr, Y_centr, k, 0, 0, 0);

	// Рисование профиля дорожки качения кольца и результата аппроксимации профиля рядом Фурье
	for (k=0; k<N; k++)
	{
		priz = line( buf_rezult_graph, *(X1_Array+k), *(Y1_Array+k), *(X1_Array+k+1), *(Y1_Array+k+1), 0, 255, 0 );
		priz = line( buf_rezult_graph, *(X2_Array+k), *(Y2_Array+k), *(X2_Array+k+1), *(Y2_Array+k+1), 0, 0, 255 );
	}
	
	priz = save_bmp("REZULT_GRAPH.BMP", buf_rezult_graph );					// Сохранить в файле "REZULT_GRAPH.BMP" образ BMP-файла содержащего графическое представление результатов расчета
}

/////////////////////////////////////////////////////////////////////////////////////////////////
///
free(R_kriv2);		// Освободить область памяти выделенную под хранение массива "R_kriv2"
///
/////////////////////////////////////////////////////////////////////////////////////////////////

free(a_proizvod_2);	// Освободить область памяти выделенный под хранение массива "a_proizvod_2"
free(a_proizvod_1);	// Освободить область памяти выделенный под хранение массива "a_proizvod_1"
free(R_kriv);		// Освободить блок памяти выделенный под хранение массива "R_kriv"
free(Y2_Array);		// Освободжить блок памяти выделенный под хранение массива "Y2_Array"
free(Y1_Array);		// Освободжить блок памяти выделенный под хранение массива "Y1_Array"
free(X2_Array);		// Освободжить блок памяти выделенный под хранение массива "X1_Array"
free(X1_Array);		// Освободжить блок памяти выделенный под хранение массива "X1_Array"
free(sum_fure);		// Освободить блок памяти выделенный для хранения массива "sum_fure"
fclose(f2);		// Закрыть файл в который записаны результаты расчета.
free(aa);		// Освободить ранее выделенный блок памяти выделенный под хранение коэффициентов Фурье
free(profil);		// Освободить блок памяти выделенный под массив профиля дорожки качения кольца
fclose(f1);		// Закрыть файл из которого прочитаны исходные данные.
free(stroka);		// Освободить блок памяти под хранения строки


// Выход из программы c признаком нормального завершения
return 0;


}
